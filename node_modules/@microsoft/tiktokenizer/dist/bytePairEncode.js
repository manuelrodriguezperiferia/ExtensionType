"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.bytePairEncode = exports.BinaryMap = exports.binaryMapKey = void 0;
// exported for testing
const binaryMapKey = (k, start, end) => {
    const length = end - start;
    // 'lower' and 'upper' are both 24-bit integers, like
    //    0xFF FF FF
    //      ^3 ^2 ^1
    // If we say have a length of 2, we should disregard the last "3" byte, so we
    // create a mask like
    //    0x00 FF FF  (started at 0xFF FF FF and shifted over by 8 bits)
    //      ^3 ^2 ^1
    // so that we discard the data outside our range
    const lowerMask = 0xFFFFFF >>> Math.max(0, (3 - length) * 8);
    const lower = (k[start + 0] | (k[start + 1] << 8) | (k[start + 2] << 16)) & lowerMask;
    const upperMask = 0xFFFFFF >>> Math.min(31, Math.max(0, (6 - length) * 8));
    const upper = (k[start + 3] | (k[start + 4] << 8) | (k[start + 5] << 16)) & upperMask;
    return lower + (0x1000000 * upper);
};
exports.binaryMapKey = binaryMapKey;
class BinaryMap {
    constructor() {
        this.nested = new Map();
        this.final = new Map();
    }
    get(key, start = 0, end = key.length) {
        const isFinal = end < 6 /* Constant.BytesPerLevel */ + start;
        const mapKey = (0, exports.binaryMapKey)(key, start, end);
        if (isFinal) {
            return this.final.get(mapKey);
        }
        return this.nested.get(mapKey)?.get(key, 6 /* Constant.BytesPerLevel */ + start, end);
    }
    set(key, value) {
        const k = (0, exports.binaryMapKey)(key, 0, key.length);
        const isFinal = key.length < 6 /* Constant.BytesPerLevel */;
        if (isFinal) {
            this.final.set(k, value);
            return;
        }
        const existing = this.nested.get(k);
        if (existing instanceof BinaryMap) {
            existing.set(key.subarray(6 /* Constant.BytesPerLevel */), value);
        }
        else {
            const newMap = new BinaryMap();
            newMap.set(key.subarray(6 /* Constant.BytesPerLevel */), value);
            this.nested.set(k, newMap);
        }
    }
}
exports.BinaryMap = BinaryMap;
let ranksBuf = new Int32Array(128);
let indicesBuf = new Int32Array(128);
/**
 * This function implements the byte pair encoding algorithm.
 * @param mergingBytes: bytes to be merged
 * @param ranks: BPE rank for the bytes
 * @returns number[]: Encoded token ids
 */
function bytePairEncode(mergingBytes, ranks, length) {
    if (length === 1) {
        return [ranks.get(mergingBytes)];
    }
    let minRank = 2147483647 /* Constant.MaxRank */;
    let minIndex = -1;
    while (ranksBuf.length < length * 2) {
        indicesBuf = new Int32Array(indicesBuf.length * 2);
        ranksBuf = new Int32Array(ranksBuf.length * 2);
    }
    for (let i = 0; i < length - 1; i++) {
        const rank = ranks.get(mergingBytes, i, i + 2) ?? 2147483647 /* Constant.MaxRank */;
        if (rank < minRank) {
            minRank = rank;
            minIndex = i;
        }
        indicesBuf[i] = i;
        ranksBuf[i] = rank;
    }
    indicesBuf[length - 1] = length - 1;
    ranksBuf[length - 1] = 2147483647 /* Constant.MaxRank */;
    indicesBuf[length] = length;
    ranksBuf[length] = 2147483647 /* Constant.MaxRank */;
    let maxIndex = length + 1;
    function getRank(startIndex, skip = 0) {
        if (startIndex + skip + 2 < maxIndex) {
            const rank = ranks.get(mergingBytes, indicesBuf[startIndex], indicesBuf[startIndex + skip + 2]);
            if (rank !== undefined) {
                return rank;
            }
        }
        return 2147483647 /* Constant.MaxRank */;
    }
    while (minRank !== 2147483647 /* Constant.MaxRank */) {
        ranksBuf[indicesBuf[minIndex]] = getRank(minIndex, 1);
        if (minIndex > 0) {
            ranksBuf[indicesBuf[minIndex - 1]] = getRank(minIndex - 1, 1);
        }
        // splice minIndex+1 out of the array. On Node 20, this was tested to be
        // faster than `indicesBuf.set(indicesBuf.subarray(...`
        for (let i = minIndex + 1; i < maxIndex - 1; i++) {
            indicesBuf[i] = indicesBuf[i + 1];
        }
        maxIndex--;
        minIndex = -1;
        minRank = 2147483647 /* Constant.MaxRank */;
        for (let i = 0; i < maxIndex - 1; i++) {
            const rank = ranksBuf[indicesBuf[i]];
            if (ranksBuf[indicesBuf[i]] < minRank) {
                minRank = rank;
                minIndex = i;
            }
        }
    }
    const outList = [];
    for (let i = 0; i < maxIndex - 1; i++) {
        outList.push(ranks.get(mergingBytes, indicesBuf[i], indicesBuf[i + 1]));
    }
    return outList;
}
exports.bytePairEncode = bytePairEncode;
//# sourceMappingURL=bytePairEncode.js.map